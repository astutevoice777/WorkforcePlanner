import { OptimizedShift } from './openaiSchedulingService';

// Google Calendar API types
interface CalendarEvent {
  summary: string;
  description: string;
  start: {
    dateTime: string;
    timeZone: string;
  };
  end: {
    dateTime: string;
    timeZone: string;
  };
  attendees?: Array<{
    email: string;
    displayName?: string;
  }>;
  colorId?: string;
  reminders?: {
    useDefault: boolean;
    overrides?: Array<{
      method: string;
      minutes: number;
    }>;
  };
}

export class GoogleCalendarService {
  private gapi: any;
  private isInitialized = false;
  private calendarId = 'primary'; // Can be customized

  // Initialize Google API
  async initialize(): Promise<boolean> {
    try {
      // Check if API keys are configured
      if (!import.meta.env.VITE_GOOGLE_API_KEY || !import.meta.env.VITE_GOOGLE_CLIENT_ID) {
        console.error('Google API keys not configured');
        return false;
      }

      // Load Google API script if not already loaded
      if (!window.gapi) {
        await this.loadGoogleAPI();
      }

      // Wait for gapi to be ready
      await new Promise((resolve, reject) => {
        const timeout = setTimeout(() => reject(new Error('Google API load timeout')), 10000);
        window.gapi.load('client:auth2', () => {
          clearTimeout(timeout);
          resolve(undefined);
        });
      });

      // Initialize the client
      await window.gapi.client.init({
        apiKey: import.meta.env.VITE_GOOGLE_API_KEY,
        clientId: import.meta.env.VITE_GOOGLE_CLIENT_ID,
        discoveryDocs: ['https://www.googleapis.com/discovery/v1/apis/calendar/v3/rest'],
        scope: 'https://www.googleapis.com/auth/calendar'
      });

      this.gapi = window.gapi;
      this.isInitialized = true;
      return true;
    } catch (error) {
      console.error('Failed to initialize Google Calendar API:', error);
      return false;
    }
  }

  private loadGoogleAPI(): Promise<void> {
    return new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = 'https://apis.google.com/js/api.js';
      script.onload = () => resolve();
      script.onerror = () => reject(new Error('Failed to load Google API'));
      document.head.appendChild(script);
    });
  }

  // Sign in to Google
  async signIn(): Promise<boolean> {
    try {
      if (!this.isInitialized) {
        const initialized = await this.initialize();
        if (!initialized) {
          throw new Error('Failed to initialize Google API');
        }
      }

      if (!this.gapi || !this.gapi.auth2) {
        throw new Error('Google Auth2 not available');
      }

      const authInstance = this.gapi.auth2.getAuthInstance();
      if (!authInstance) {
        throw new Error('Auth instance not available');
      }

      if (authInstance.isSignedIn.get()) {
        return true;
      }

      await authInstance.signIn();
      return authInstance.isSignedIn.get();
    } catch (error) {
      console.error('Google Calendar sign-in failed:', error);
      return false;
    }
  }

  // Check if user is signed in
  isSignedIn(): boolean {
    if (!this.isInitialized || !this.gapi) return false;
    const authInstance = this.gapi.auth2.getAuthInstance();
    return authInstance.isSignedIn.get();
  }

  // Sign out from Google
  async signOut(): Promise<void> {
    if (this.isInitialized && this.gapi) {
      const authInstance = this.gapi.auth2.getAuthInstance();
      await authInstance.signOut();
    }
  }

  // Convert shift to calendar event
  private shiftToCalendarEvent(shift: OptimizedShift, businessName: string): CalendarEvent {
    const startDateTime = new Date(`${shift.date}T${shift.start_time}:00`);
    const endDateTime = new Date(`${shift.date}T${shift.end_time}:00`);

    return {
      summary: `${businessName} - ${shift.role_name}`,
      description: `
Work Shift Details:
• Role: ${shift.role_name}
• Duration: ${shift.duration} hours
• Pay Rate: $${shift.pay_rate}/hour
• Estimated Pay: $${(shift.duration * shift.pay_rate).toFixed(2)}
• Confidence Score: ${(shift.confidence_score * 100).toFixed(1)}%

Reasoning: ${shift.reasoning}

Generated by AI Staff Maker
      `.trim(),
      start: {
        dateTime: startDateTime.toISOString(),
        timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
      },
      end: {
        dateTime: endDateTime.toISOString(),
        timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
      },
      colorId: '9', // Blue color for work shifts
      reminders: {
        useDefault: false,
        overrides: [
          { method: 'popup', minutes: 60 }, // 1 hour before
          { method: 'popup', minutes: 15 }  // 15 minutes before
        ]
      }
    };
  }

  // Create calendar events for all shifts
  async createScheduleEvents(
    shifts: OptimizedShift[], 
    businessName: string,
    staffEmailMap: Record<string, string>
  ): Promise<{ success: boolean; createdEvents: number; errors: string[] }> {
    if (!this.isSignedIn()) {
      throw new Error('Not signed in to Google Calendar');
    }

    const results = {
      success: true,
      createdEvents: 0,
      errors: [] as string[]
    };

    for (const shift of shifts) {
      try {
        const event = this.shiftToCalendarEvent(shift, businessName);
        
        // Add staff member as attendee if email is available
        const staffEmail = staffEmailMap[shift.staff_id];
        if (staffEmail) {
          event.attendees = [{
            email: staffEmail,
            displayName: shift.staff_name
          }];
        }

        const response = await this.gapi.client.calendar.events.insert({
          calendarId: this.calendarId,
          resource: event,
          sendUpdates: 'all' // Send email invitations to attendees
        });

        if (response.status === 200) {
          results.createdEvents++;
        } else {
          results.errors.push(`Failed to create event for ${shift.staff_name} on ${shift.date}`);
        }
      } catch (error: any) {
        results.errors.push(`Error creating event for ${shift.staff_name}: ${error.message}`);
        results.success = false;
      }
    }

    return results;
  }

  // Create a single calendar event
  async createSingleEvent(
    shift: OptimizedShift, 
    businessName: string, 
    staffEmail?: string
  ): Promise<boolean> {
    try {
      if (!this.isSignedIn()) {
        throw new Error('Not signed in to Google Calendar');
      }

      const event = this.shiftToCalendarEvent(shift, businessName);
      
      if (staffEmail) {
        event.attendees = [{
          email: staffEmail,
          displayName: shift.staff_name
        }];
      }

      const response = await this.gapi.client.calendar.events.insert({
        calendarId: this.calendarId,
        resource: event,
        sendUpdates: 'all'
      });

      return response.status === 200;
    } catch (error) {
      console.error('Failed to create calendar event:', error);
      return false;
    }
  }

  // Get user's calendar list
  async getCalendars(): Promise<Array<{ id: string; summary: string; primary?: boolean }>> {
    try {
      if (!this.isSignedIn()) return [];

      const response = await this.gapi.client.calendar.calendarList.list();
      return response.result.items || [];
    } catch (error) {
      console.error('Failed to fetch calendars:', error);
      return [];
    }
  }

  // Set which calendar to use
  setCalendarId(calendarId: string): void {
    this.calendarId = calendarId;
  }

  // Delete events for a specific date range (useful for schedule updates)
  async deleteScheduleEvents(startDate: string, endDate: string): Promise<boolean> {
    try {
      if (!this.isSignedIn()) return false;

      const response = await this.gapi.client.calendar.events.list({
        calendarId: this.calendarId,
        timeMin: new Date(`${startDate}T00:00:00`).toISOString(),
        timeMax: new Date(`${endDate}T23:59:59`).toISOString(),
        q: 'Generated by AI Staff Maker'
      });

      const events = response.result.items || [];
      
      for (const event of events) {
        await this.gapi.client.calendar.events.delete({
          calendarId: this.calendarId,
          eventId: event.id
        });
      }

      return true;
    } catch (error) {
      console.error('Failed to delete schedule events:', error);
      return false;
    }
  }
}

export const googleCalendarService = new GoogleCalendarService();
